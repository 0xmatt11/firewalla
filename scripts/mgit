#!/bin/bash

# ----------------------------------------------------------------------------
# This is a wrapper of Git that can recover given local repository from
# disruptive action, like power off or SD card extraction.
# ----------------------------------------------------------------------------

MARKER_BASE=$HOME/git_in_progress
LOCK_RETRY=1000
ERR_LOCK_NOTFOUND=2
ERR_LOCK_INVALID=3
ERR_LOCK_TIMEOUT=4

function marked_git {
    _rc=0
    wsdir=$(basename $PWD)
    marker_dir=$MARKER_BASE/$wsdir
    mkdir -p $marker_dir
    git remote get-url origin > $marker_dir/url
    git rev-parse --abbrev-ref HEAD > $marker_dir/branch
    if obtain_lock $wsdir
    then
        git "$@" || _rc=1
        release_lock $wsdir
    else
        _rc=1
    fi
    return $_rc

}

function validate_lock {
    wsdir=$1
    obtain=$2
    lock_file=$MARKER_BASE/$wsdir/pid
    cnt=0
    while [[ $cnt -lt $LOCK_RETRY ]]
    do
        (( cnt++ ))
        # no existing lock, try lock it
        test -e $lock_file || {
            if [[ -n "$obtain" ]]
            then
                # obtain lock
                mkdir -p $MARKER_BASE/$wsdir
                echo $$ > $lock_file
            else
                # check only and return error
                return $ERR_LOCK_NOTFOUND
            fi
        }
        lpid=$(cat $lock_file)
        # invalid lock detected
        test -e /proc/$lpid || return $ERR_LOCK_INVALID
        if [[ "$lpid" == "$$" ]]
        then
            # valid lock obtained
            return 0
        else
            # valid lock owned by others, wait for it to release
            sleep 3
        fi
    done

    # timeout
    return $ERR_LOCK_TIMEOUT
}

function obtain_lock {
    validate_lock $1 obtain
}

function release_lock {
    wsdir=$1
    lock_file=$MARKER_BASE/$wsdir/pid
    if [[ -e $lock_file ]]
    then
        rm -f $lock_file
    fi
}

function recover {
    _rc=0
    cd $HOME
    for wsdir in $(ls -a $MARKER_BASE)
    do
        case $wsdir in

            .|..)
            continue
            ;;

            *)
            # try to validate lock
            validate_lock $wsdir; rc1=$?

            # try to do "git status ..."
            gs_out=$(cd $wsdir; git status -uno --porcelain); rc2=$?

            # recover if lock invalid or git status failed
            if [[ $rc1 -eq $ERR_LOCK_INVALID || $rc2 -ne 0 ]]
            then
                repo=$(cat $MARKER_BASE/$wsdir/url)
                branch=$(cat $MARKER_BASE/$wsdir/branch)
                if [[ -e ${wsdir}.bak ]]
                then
                    rm -rf $wsdir
                else
                    mv $wsdir ${wsdir}.bak
                fi
                if git clone --branch $branch --single-branch $repo $wsdir
                then
                    # recover OK
                    rm -rf ${wsdir}.bak
                    release_lock $wsdir
                else
                    # recover failed
                    _rc=1
                fi
            fi
            ;;
        esac
    done
    return $_rc
}


# ----------------------------------------------------------------------------
# MAIN goes here
# ----------------------------------------------------------------------------

rc=0
if [[ $# -eq 0 ]]; then
    git
else
    # Protect file related Git operations(fetch/pull/reset) with marker files
    case $1 in

        fetch|pull|reset)
            marked_git "$@" || rc=1
            ;;

        recover)
            recover || rc=1
            ;;

        *)
            git "$@" || rc=1
            ;;
    esac
fi

exit $rc
